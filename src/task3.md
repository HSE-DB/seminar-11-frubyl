## Задание 3

1. Создайте таблицу с большим количеством данных:
    ```sql
    CREATE TABLE test_cluster AS 
    SELECT 
        generate_series(1,1000000) as id,
        CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
        md5(random()::text) as data;
    ```

2. Создайте индекс:
    ```sql
    CREATE INDEX test_cluster_cat_idx ON test_cluster(category);
    ```

3. Измерьте производительность до кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=59.17..7696.73 rows=5000 width=68) (actual time=11.703..94.696 rows=500350 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=8334
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..57.92 rows=5000 width=0) (actual time=10.333..10.333 rows=500350 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 0.575 ms
    Execution Time: 105.192 ms
    ```

    *Объясните результат:*
    Запрос использует Bitmap Heap Scan с индексом по category. Execution Time составляет 105.192 мс.
    Найдено 500350 строк из 1 миллиона (примерно 50%, что ожидаемо при random() < 0.5).
    Heap Blocks: exact=8334 показывает, что пришлось прочитать 8334 блока данных.
    Данные не упорядочены по category, поэтому строки с category='A' разбросаны по всей таблице,
    что требует чтения большого количества блоков.

4. Выполните кластеризацию:
    ```sql
    CLUSTER test_cluster USING test_cluster_cat_idx;
    ```
    
    *Результат:*
    CLUSTER успешно выполнен. Команда CLUSTER физически переупорядочивает таблицу на диске
    в соответствии с порядком индекса test_cluster_cat_idx. После кластеризации все строки
    с category='A' будут сгруппированы вместе, а строки с category='B' - в другой части таблицы.
    Это улучшает локальность данных и уменьшает количество блоков, которые нужно прочитать.

5. Измерьте производительность после кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=5590.53..20192.44 rows=501433 width=39) (actual time=9.919..62.698 rows=500350 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=4170
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..5465.17 rows=501433 width=0) (actual time=9.373..9.373 rows=500350 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 0.727 ms
    Execution Time: 72.579 ms
    ```

    *Объясните результат:*
    После кластеризации производительность значительно улучшилась:
    - Execution Time: снизилось с 105.192 мс до 72.579 мс (улучшение на 31%)
    - Heap Blocks: уменьшилось с 8334 до 4170 блоков (в 2 раза меньше!)

    Кластеризация сгруппировала все строки с category='A' вместе, что означает меньше
    случайных обращений к диску и лучшее использование кэша. Количество прочитанных блоков
    сократилось в 2 раза, так как данные теперь расположены последовательно.

6. Сравните производительность до и после кластеризации:

    *Сравнение:*
    Кластеризация таблицы test_cluster показала значительные улучшения:

    **До кластеризации:**
    - Execution Time: 105.192 мс
    - Heap Blocks: exact=8334
    - Найдено: 500350 строк
    - Проблема: данные с category='A' разбросаны по всей таблице

    **После кластеризации:**
    - Execution Time: 72.579 мс
    - Heap Blocks: exact=4170
    - Найдено: 500350 строк (то же количество)
    - Улучшение: данные физически упорядочены по category

    **Улучшения:**
    - Скорость выполнения: улучшение на 31% (32.6 мс быстрее)
    - Количество блоков: сокращение в 2 раза (4164 блока меньше)
    - I/O операций: значительно меньше случайных обращений к диску

    **Выводы:**
    - Кластеризация особенно эффективна для запросов, которые выбирают большой процент строк
    - Лучшая локальность данных улучшает работу дискового кэша
    - Уменьшение количества блоков прямо влияет на производительность I/O
    - Для таблиц с частыми запросами по определенному полю кластеризация дает существенный эффект
    - Важно помнить, что кластеризация - одноразовая операция, таблица не остается кластеризованной
      при последующих вставках/обновлениях (требуется периодическая рекластеризация)